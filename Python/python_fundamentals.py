# -*- coding: utf-8 -*-
"""python_fundamentals.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qgxCaQMat_ivRhixSDsNLLlzgWmp1u4p

# **🚀 Python Tutorial**

This intensive and practical guide will help you internalize Python's core concepts for real-world applications in record time.

# **🚀 Step 1: Python Built-in Functions**
Python’s built-in functions are essential for efficiency and writing clean code.  

**1️⃣ What Are Built-in Functions?**
Built-in functions are functions that come with Python—no need to `import` anything.  
These functions handle common tasks like math, string operations, type conversions, and iteration.

## **2️⃣ Most Important Built-in Functions (Grouped by Category)**

**🔹 Type & Conversion Functions**

Quickly convert between types during debugging and data processing.

| Function | What It Does | Example |
|----------|-------------|---------|
| `type()` | Returns the type of a variable | `type(10)  # int` |
| `str()` | Converts to string | `str(10)  # '10'` |
| `int()` | Converts to integer | `int('10')  # 10` |
| `float()` | Converts to float | `float('3.14')  # 3.14` |
| `bool()` | Converts to boolean | `bool(0)  # False` |
| `list()` | Converts to a list | `list("abc")  # ['a', 'b', 'c']` |
| `tuple()` | Converts to a tuple | `tuple([1,2,3])  # (1,2,3)` |
| `dict()` | Creates a dictionary | `dict(name="Alice", age=25)` |
| `set()` | Converts to a set (removes duplicates) | `set([1,2,2,3])  # {1,2,3}` |

**🔹 String Manipulation**

`ord()` and `chr()` are useful for encryption, while `format()` is used for rounding and display.

| Function | What It Does | Example |
|----------|-------------|---------|
| `len()` | Returns length of string/list | `len("hello")  # 5` |
| `ord()` | Returns ASCII value of char | `ord('A')  # 65` |
| `chr()` | Converts ASCII to char | `chr(65)  # 'A'` |
| `format()` | Formats strings | `"{:.2f}".format(3.14159)  # '3.14'` |

**🔹 Math & Numeric Functions**

| Function | What It Does | Example |
|----------|-------------|---------|
| `abs()` | Returns absolute value | `abs(-5)  # 5` |
| `round()` | Rounds a number | `round(3.14159, 2)  # 3.14` |
| `sum()` | Sums items in an iterable | `sum([1,2,3])  # 6` |
| `min()` | Returns min value | `min(3, 7, 1)  # 1` |
| `max()` | Returns max value | `max(3, 7, 1)  # 7` |
| `pow()` | Raises to power | `pow(2, 3)  # 8` |

**🔹 Iteration & Filtering**

`zip()` is great for merging lists, while `map()` and `filter()` replace slow loops

| Function | What It Does | Example |
|----------|-------------|---------|
| `range()` | Generates a sequence | `range(5)  # [0,1,2,3,4]` |
| `enumerate()` | Adds index to an iterable | `enumerate(['a','b'])  # [(0, 'a'), (1, 'b')]` |
| `zip()` | Combines iterables element-wise | `zip([1,2], ['a','b'])  # [(1,'a'), (2,'b')]` |
| `map()` | Applies function to iterable | `map(str.upper, ['hello','world'])  # ['HELLO','WORLD']` |
| `filter()` | Filters elements by condition | `filter(lambda x: x>5, [3,6,9])  # [6,9]` |

**🔹 Advanced Functional Programming**

| Function | What It Does | Example |
|----------|-------------|---------|
| `all()` | Returns `True` if all elements are `True` | `all([True, True, False])  # False` |
| `any()` | Returns `True` if any element is `True` | `any([False, False, True])  # True` |
| `sorted()` | Returns sorted list | `sorted([3,1,2])  # [1,2,3]` |

**🔹 Hidden Gems: Must-Know Built-ins**

`hex()` and `bin()` are important for bitwise operations.  
Never use `eval()` with user input (security risk!).

| Function | What It Does | Example |
|----------|-------------|---------|
| `next()` | Gets next item from an iterator | `next(iter([1,2,3]))  # 1` |
| `eval()` | Evaluates a Python expression (⚠️ Dangerous) | `eval("2+3")  # 5` |
| `globals()` | Returns global variables dictionary | `globals()['x'] = 10` |
| `locals()` | Returns local variables dictionary | `locals()` |
| `hex()` | Converts int to hexadecimal | `hex(255)  # '0xff'` |
| `bin()` | Converts int to binary | `bin(5)  # '0b101'` |

**🔹Best Practices for Built-in Functions**

✅ Use built-ins instead of manual loops whenever possible.  
✅ Know which functions modify data (`list.sort()`) vs. return new data (`sorted()`).  
✅ Understand `key` parameters (`sorted(data, key=lambda x: x[1])`).  

---

**🔥 Challenge: Apply Built-ins**

Write a function that:
1. Takes a list of numbers.
2. Filters out numbers ≤ 5 using `filter()`.
3. Converts them to strings using `map()`.
4. Sorts them in descending order using `sorted()`.
5. Returns a single string with `" -> "` between numbers.

✅ Example Input: `[1, 10, 3, 7, 5, 9]`  
✅ Expected Output: `"10 -> 9 -> 7"`
"""

def fun(nums):
    if not nums:
        raise ValueError("The list can not be empty.")
    nums_filtered = list(filter(lambda x: x > 5, nums))
    if not nums_filtered:
        return ""
    nums_mapped = map(str, nums_filtered)
    nums_sorted = sorted(nums_mapped, reverse=True)
    return " -> ".join(nums_sorted)

# Example Usage:
print(fun([3, 5, 6, 8, 32, 9, 6, 31]))

"""**Do You Need to Use `list()` on `map()`?**

✅ Yes, you should use `list(map(...))` if you need to store or iterate over the results multiple times.  
❌ No, if you are just using it once in a loop or passing it to another function like `sorted()`.

🔍 Why?

- `map()` returns a lazy iterator (like `filter()`).  
- Iterators are consumed once → If you loop over them or convert to another type, you lose access to the data.

# **🚀 Step 2: Mastering Python’s Core Data Structures (Lists, Dicts, Sets, Tuples)**
Forget memorizing every data structure. Focus on the ones that will deliver results in 90% of cases.

### **🔹 Lists - Your Everyday Workhorse**

✅ Fast operations: Append, pop, slice, and comprehension.

✅ Common uses: Storing and filtering data, list comprehension, mapping functions.

**📌 List Comprehensions**

A list comprehension follows this structure:

```python
[expression for item in iterable if condition]
```
🔹 `expression` → What we do to each item (e.g., modify it, transform it).  
🔹 `item` → The current element in the iterable (e.g., list, range, string).  
🔹 `iterable` → The source data (list, range, file, etc.).  
🔹 `if condition` (optional) → Filters which elements to include.
"""

# Creating a list dynamically
nums = [i for i in range(1, 11)]

# Filtering
evens = [x for x in nums if x % 2 == 0]

# Mapping
squares = [x**2 for x in nums]

# Sorting based on the absolute value
data= [-5, -1, 4, 8]
sorted_list = sorted(data, key = abs)
print(f"The sorted liost based on absolute value: {sorted_list}")
# The key=abs argument in Python's sorted() function is used to sort elements
# based on their absolute values rather than their original values.

# Sorting based on the length of the string
words = ["apple", "banana", "kiwi", "grape"]
sorted_words = sorted(words, key=len)
print(f"The sorted list based on length of the word: {sorted_words}")

# Sorting based on the last character of a string
sorted_words = sorted(words, key=lambda x: x[-1])
print(f"The sorted list based on the last character of a string: {sorted_words}")

"""**🔥 Common Interview Pitfalls**
```python
# 🚨 Slow way to copy a list
new_list = old_list[:]  # Avoid this, use old_list.copy()

# 🚨 Avoid modifying a list while iterating
for x in nums:
    if x < 5:
        nums.remove(x)  # This causes skipping issues! Instead, use list comprehension.
```
"""

nums = [i for i in range(1, 11)]
nums = [x for x in nums if x >= 5]

# Why does this work?
# It creates a new list instead of modifying the original list during iteration.
# It’s faster and more readable.

"""**✅ Example 1: Basic List Comprehension (Squaring Numbers)**

**Without list comprehension:**
```python
numbers = [1, 2, 3, 4, 5]
squared = []

for num in numbers:
    squared.append(num ** 2)

print(squared)  # Output: [1, 4, 9, 16, 25]
```

**With list comprehension:**
```python
squared = [num ** 2 for num in numbers]
print(squared)  # Output: [1, 4, 9, 16, 25]
```
---

**✅ Example 2: Using a Condition (Filter Even Numbers)**

**Without list comprehension:**
```python
evens = []
for num in range(10):
    if num % 2 == 0:
        evens.append(num)

print(evens)  # Output: [0, 2, 4, 6, 8]
```

**With list comprehension:**
```python
evens = [num for num in range(10) if num % 2 == 0]
print(evens)  # Output: [0, 2, 4, 6, 8]
```
💡 Explanation:
- `num for num in range(10)` → Loops through 0–9.
- `if num % 2 == 0` → Keeps only even numbers.

---

**✅ Example 3: Transforming & Filtering at the Same Time**

Convert numbers to strings, but only if they are even
```python
numbers = [1, 2, 3, 4, 5, 6]

str_evens = [str(num) for num in numbers if num % 2 == 0]
print(str_evens)  # Output: ['2', '4', '6']
```
---

**✅ Example 4: Nested Loops in List Comprehensions**

**Without list comprehension:**
```python
pairs = []
for x in range(3):
    for y in range(3):
        pairs.append((x, y))

print(pairs)  
# Output: [(0,0), (0,1), (0,2), (1,0), (1,1), (1,2), (2,0), (2,1), (2,2)]
```

**With list comprehension:**
```python
pairs = [(x, y) for x in range(3) for y in range(3)]
print(pairs)
```
---

**✅ Example 5: Changing Values Based on a Condition (Ternary If-Else)**
```python
numbers = [1, 2, 3, 4, 5]

labels = ["even" if num % 2 == 0 else "odd" for num in numbers]
print(labels)  # Output: ['odd', 'even', 'odd', 'even', 'odd']
```
---

**✅ Example 6: Flattening a List of Lists**
```python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

flat_list = [num for row in matrix for num in row]
print(flat_list)  # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]
```
💡 Explanation:
- First `for` loops through each row.
- Second `for` extracts numbers.

**🔥 How to Come Up with a List Comprehension for Flattening a List of Lists**

1️⃣ Understand the Input and Expected Output
If you’re given a nested list like:
```python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
```
You need to flatten it into:
```python
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```
This means removing the nested structure and putting all elements in one single list.

---

2️⃣ Think About How a `for` Loop Would Work
If you're unsure about list comprehensions, always write a regular loop first.

```python
flat_list = []
for row in matrix:   # Loop through each sub-list
    for num in row:  # Loop through each element in the sub-list
        flat_list.append(num)

print(flat_list)  # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]
```
This loop:
- First loop: Iterates through each list inside `matrix`.
- Second loop: Iterates through each number inside each sub-list.
- Appends each number into `flat_list`.

---

3️⃣ Convert the Loop into a List Comprehension

💡 **Key trick:**  
- The **inner loop comes first** (looping through numbers inside each row).  
- The **outer loop comes second** (looping through rows in the matrix).

```python
flat_list = [num for row in matrix for num in row]
print(flat_list)  # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

---

If the list is deeply nested (more than 2 levels), list comprehension won’t work.  
Use Recursion:
```python
def flatten(nested_list):
    return [item for sublist in nested_list for item in (flatten(sublist) if isinstance(sublist, list) else [sublist])]

nested = [[1, [2, 3]], [4, [5, 6]], [7, 8, 9]]
print(flatten(nested))  
# Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]
```
"""

nested_list = [[10, 20, 30], [40, 50], [60, 70, 80, 90]]

new_list = []
for row in nested_list:
    for num in row:
        new_list.append(num)

new_list = [num for row in nested_list for num in row]
new_list

new_list = []
nested_list = [["a", "b"], ["c", "d", "e"], ["f", "g"]]
for row in nested_list:
    for char in row:
        new_list.append(char)

new_list = [char for row in nested_list for char in row]
new_list

# The isinstance() function is a built-in Python function used to check whether a
# variable is an instance of a specific type or class.

def flatten(nested_list):
    flat_list = []
    for item in nested_list:
        if isinstance(item, list):
            flat_list.extend(flatten(item))
        else:
            flat_list.append(item)
    return flat_list

def flatten(nested_list):
    return [item for sublist in nested_list for item in (flatten(sublist) if isinstance(sublist, list) else [sublist])]
# Test with a deeply nested list
deep_nested = [[1, [2, 3]], [4, [5, [6, 7]]], [8, 9]]
print(flatten(deep_nested))

"""### **🔹 Dictionaries - Fastest Key-Value Lookups**

✅ Used for storing key-value pairs, counting occurrences, indexing data.

✅ Why? O(1) lookup speed.

1️⃣ Creating Dictionaries
"""

# Basic dictionary
data = {"name": "Alice",
        "age": 25,
        "city": "New York"}

# Using dict() constructor
person = dict(name="Bob", age=30, job="Engineer")

# Complex dictionaries with mixed data types
complex_dict = {
    "id": 101,
    "scores": [85, 90, 95],
    "details": {"height": 5.7, "weight": 70}
}
print(complex_dict["details"]["height"])

"""2️⃣ Dictionary Operations"""

data = {"name": "Alice",
        "age": 25,
        "city": "New York"}

# Adding and updating values
data["age"] = 26
data["country"] = "USA"

# Check if a value exists
print("age" in data)
print("salary" in data)

# Safely getting values
print(data.get("age"))
print("salary", "Not found")

# Deleting a key
del data["city"]
print(data)

# Poping a key (Return and remove)
age = data.pop("age")
print(age)
print(data)

# Clearing a dict
data.clear()
print(data)

"""3️⃣ Iterating Over Dictionaries"""

# Loop through keys
for key in person:
    print(key, end=", ")

# Loop through values
for value in person.values():
    print(value, end=", ")

# Loop through key-value pairs
for key, value in person.items():
    print(f"\n{key}: {value}")

"""**📌 Deep Dive into Dictionary Comprehensions**

Dictionary comprehensions allow you to create dictionaries in a single, concise line instead of using loops. They are faster, cleaner, and more Pythonic—essential for writing efficient and readable code.

```python
{key_expression: value_expression for item in iterable if condition}
```
🔹 **`key_expression`** → How to compute each key.  
🔹 **`value_expression`** → How to compute each value.  
🔹 **`iterable`** → The data source (list, range, dictionary, etc.).  
🔹 **`if condition`** _(optional)_ → Filters which elements to include.

**✅ Creating a Dictionary from a List**

Example: Squaring Numbers and Using Them as Keys

**Without Dictionary Comprehension:**
```python
numbers = [1, 2, 3, 4, 5]
squares = {}
for num in numbers:
    squares[num] = num ** 2

print(squares)  
# Output: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
```

**With Dictionary Comprehension:**
```python
squares = {num: num ** 2 for num in numbers}
print(squares)
# Output: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
```

---

**✅ Filtering a Dictionary Using a Condition**

Example: Keep Students Who Passed

**Without Dictionary Comprehension:**
```python
students = {"Alice": 85, "Bob": 72, "Charlie": 91, "David": 65}
passed_students = {}
for name, score in students.items():
    if score >= 75:
        passed_students[name] = score

print(passed_students)  
# Output: {'Alice': 85, 'Charlie': 91}
```

**With Dictionary Comprehension:**
```python
passed_students = {name: score for name, score in students.items() if score >= 75}
print(passed_students)
# Output: {'Alice': 85, 'Charlie': 91}
```

---

**✅ Transforming an Existing Dictionary**

Example: Convert Scores to Grade Labels
```python
scores = {"Alice": 85, "Bob": 72, "Charlie": 91}

grades = {name: "Pass" if score >= 75 else "Fail" for name, score in scores.items()}
print(grades)
# Output: {'Alice': 'Pass', 'Bob': 'Fail', 'Charlie': 'Pass'}
```

---

**✅ Swapping Keys and Values**

Example: Reverse a Dictionary
```python
original = {"a": 1, "b": 2, "c": 3}
reversed_dict = {value: key for key, value in original.items()}
print(reversed_dict)
# c Output: {1: 'a', 2: 'b', 3: 'c'}
```

---

**✅ Using `zip()` with Dictionary Comprehensions**

Example: Combine Two Lists into a Dictionary
```python
keys = ["name", "age", "city"]
values = ["Alice", 25, "New York"]

person = {k: v for k, v in zip(keys, values)}
print(person)
# Output: {'name': 'Alice', 'age': 25, 'city': 'New York'}
```
👉 `zip(keys, values)` pairs up items from two lists.

---

**✅ Nested Dictionary Comprehensions

Example: Create a Multiplication Table**
```python
multiplication_table = {x: {y: x * y for y in range(1, 6)} for x in range(1, 6)}
print(multiplication_table[3])
# Output: {1: 3, 2: 6, 3: 9, 4: 12, 5: 15}
```

---

**🔥 Quick Interview Challenge**
Write a dictionary comprehension that converts a list of words into a dictionary where:
1. The word is the key.
2. The length of the word is the value.
3. Only include words that have more than 3 letters.

Example:
```python
words = ["apple", "is", "banana", "good", "it", "python"]
```
Expected Output:
```python
{'apple': 5, 'banana': 6, 'good': 4, 'python': 6}
```
"""

words = ["apple", "is", "banana", "good", "it", "python"]
words_dict = {word : len(word) for word in words}
words_dict

"""**🔥 Common Interview Pitfalls**
```python
# 🚨 Don't modify dict while iterating
for key in data.keys():
    if key.startswith("user_1"):
        del data[key]  # ❌ Raises RuntimeError
```
**✅ Fix:** Convert to a list first:  
```python
for key in list(data.keys()):
    if key.startswith("user_1"):
        del data[key]
```

## **🔹 Sets - Fast Membership Checks**

✅ Used for removing duplicates, checking if a value exists (O(1) lookup time).

Examples:
```python
users = {"Alice", "Bob", "Charlie"}
users.add("David")  # O(1) insert
print("Charlie" in users)  # O(1) lookup
```

# **🚀 Step 3: Functions That Make Your Code Cleaner**

1️⃣ Why Use Functions?

**Reusability:** Instead of rewriting the same logic, call a function.

**Readability:** Functions modularize your code and make it easier to understand.

**Maintainability:** Fix bugs or update logic in one place, not everywhere.

✅ Examples:
```python
# One-liner function (Lambda)
add = lambda x, y: x + y
print(add(3, 5))

# Default arguments & unpacking
def process(x, y=10, *args, **kwargs):
    print(f"x: {x}, y: {y}, args: {args}, kwargs: {kwargs}")

process(5, 20, "extra1", "extra2", key1="value1")
```

2️⃣ Variable-Length Arguments: `*args` & `**kwargs`

***args** → Accepts any number of positional arguments as a tuple.

****kwargs** → Accepts any number of keyword arguments as a dictionary.

```python
def dynamic_sum(*args):
    return sum(args)

print(dynamic_sum(1, 2, 3))  # Output: 6
print(dynamic_sum(10, -5))   # Output: 5
```
```python
def config_printer(**kwargs):
    for key, value in kwargs.items():
        print(f"{key} = {value}")

config_printer(user="Alice", role="Admin", location="USA")
# Output:
# user = Alice
# role = Admin
# location = USA
```
3️⃣ Lambda (One-Line) Functions
Lambda functions are quick throwaway functions without a name.

```python
multiply = lambda x, y: x * y
result = multiply(3, 4)
print(result)  # ✅ Output: 12
Great for simple operations, but can become hard to read if logic is complex.
Often used in sorting, filtering, or mapping (e.g., sorted(list, key=lambda x: x[1])).
```

4️⃣ Docstrings & Type Hints (Clean & Professional!)
Document your functions so others know exactly how to use them.

Docstrings:
```python
def greet(name: str) -> None:
    '''
    Prints a greeting to the console.

    :param name: The person's name as a string.
    :return: None
    '''
    print(f"Hello, {name}!")

```

🚀 **Quick Challenges**
1. Write a function parse_csv that:
*   Takes: filename & delimiter (default to comma).
*   Returns: A list of rows, each row is a list of columns.

2. Write a function discount_calculator(*prices, discount=0.1):

*   Multiplies each price by (1 - discount).
*   Prints or returns the discounted prices.

**(Bonus):** Combine everything. For example, a function that loads JSON data, then filters the user records where age > 30, multiplies the user’s scores by 1.2, and returns them.

**`pd.read_csv` vs `csv.reader`**

```python
import csv
import pandas as pd

def parse_csv(filename, delimiter=",", use_pandas=False):
    '''
    Parses a CSV file using either csv.reader (returns list) or pandas (returns DataFrame).

    :param filename: CSV file path.
    :param delimiter: The delimiter used in the CSV (default: comma `,`).
    :param use_pandas: If True, returns a pandas DataFrame; otherwise, returns a list of lists.
    :return: DataFrame if use_pandas=True, otherwise a list of rows.
    '''
    if use_pandas:
        return pd.read_csv(filename, delimiter=delimiter)  # Load as DataFrame
    
    # Use csv.reader for lightweight parsing
    with open(filename, "r", newline="") as file:
        reader = csv.reader(file, delimiter=delimiter)
        return [row for row in reader]  # Return list of lists

# Example Usage:
csv_file = "sample.csv"

# ✅ Get as list of lists (csv.reader method)
data_list = parse_csv(csv_file)
print("List-Based Output:", data_list)

# ✅ Get as DataFrame (pandas method)
df = parse_csv(csv_file, use_pandas=True)
print("\nDataFrame Output:\n", df)
```
"""

import csv
def parse_csv(file_name, delimiter=","):
    with open(file_name, "r") as file:
        reader = csv.reader(file, delimiter=delimiter)
        return [row for row in reader]

# The * before prices allows the function to accept any number of positional arguments.
# These arguments are collected into a tuple, meaning you can pass in multiple prices dynamically.

# Arguments must be passed as key-value pairs.	❌ Use **kwargs instead

def discount_calculator(*prices, discount=0.1):
    output = [round(price*(1-discount),2) for price in prices]
    return output

# Example usage:
print(discount_calculator(100, 200, 50))   # Output: [90.0, 180.0, 45.0]
print(discount_calculator(300, 400, discount=0.2))  # Output: [240.0, 320.0]

import json

def process_user(file_name):
    with open(file_name, "r") as file:
        data =  json.load(file)

        updated_users = {user["name"]: user["score"] * 1.2 for user in data if user["age" > 30]}
        return updated_users

"""**🔥 Real-World Challenge: Dynamic Invoice Generator**

💡 **Scenario:**  
You're building an invoice system that calculates total cost after applying a discount and optional tax or additional fees.

✅ Function Requirements

1. Accepts multiple item prices (`*args`).
2. Has an optional discount (default 10%).
3. Allows additional parameters like tax, service fee, etc. (`**kwargs`).
4. Returns a final invoice breakdown as a dictionary.
"""

def generate_invoice(*prices, discount_rate=0.1, **extra_fees):
    total_price = sum(prices)
    discounted_total = round(total_price * (1 - discount_rate) , 2)
    total_sum = discounted_total + sum(extra_fees.values())

    output_dict = {"Price" : total_price,
                   "Discount applied": discount_rate,
                   "Discounted total": discounted_total,
                   "Extra fees": extra_fees,
                   "Total": total_sum
                   }
    return output_dict

# ✅ Example Usage:
invoice = generate_invoice(100, 200, 50, discount=0.15, tax=15, service_fee=5)
print(invoice)

"""**🚀 How This Uses `*args` and `**kwargs`**

| Concept | Implementation |
|---------|---------------|
| `*args` | Accepts multiple item prices dynamically (`100, 200, 50`) |
| `discount` | Default discount of 10% (overridden by user input) |
| `**kwargs` | Allows flexible extra fees like `tax=15`, `service_fee=5` |

**🔥 Real-World Challenge: E-Commerce Order Processing System**

💡 **Scenario:**  
You're building a simple e-commerce order system that calculates the total price, applies discounts, handles shipping fees, and generates an order summary.

✅ Function Requirements

1️⃣ Accepts multiple item prices (`*prices`).  
2️⃣ Allows per-item discounts (`discounts`, default = 0 for each item).  
3️⃣ Supports extra fees (`**extra_fees`) like shipping, tax, service charge, etc.
4️⃣ Automatically applies free shipping if the total exceeds $100.  
5️⃣ Returns a detailed order summary.

✅ Expected Output
```python
{
    'Itemized Prices (After Discount)': [45.0, 24.0, 20.0],
    'Discounts Applied': [0.1, 0.2, 0],
    'Subtotal': 89.0,
    'Extra Fees': {'shipping': 5, 'tax': 7},
    'Final Total': 101.0
}
```
"""

def process_order(*prices, discounts, shipping_rate_threshold=100, **extra_fees):
    # Edge cases
    if discounts is None:
        discounts = [0] * len(prices)

    if len(prices) != len(discounts):
        raise ValueError("Discounts list must be the same length as the prices list")


    itemized = [round(price * (1 - discount), 2) for price, discount in zip(prices, discounts)]
    subtotal = sum(itemized)

    if subtotal >= shipping_rate_threshold and "shipping" in extra_fees:
        del extra_fees["shipping"]
    total_fees = sum(extra_fees.values()) if extra_fees else 0
    final_total = round(subtotal + total_fees)

    order_summary = {
        "Itemized prices (after discount)": itemized,
        "Discount applied" : discounts,
        "Subtotal": subtotal,
        "Extra fees": extra_fees,
        "Final subtotal": final_total
    }
    return order_summary
# ✅ Example Usage:
order = process_order(50, 30, 20, discounts=[0.1, 0.2, 0], shipping=5, tax=7)
print(order)

"""**🔥 Key Features Used**

| Feature | How We Used It |
|---------|---------------|
| **`*args`** | Accepts multiple item prices dynamically |
| **`**kwargs`** | Handles dynamic extra fees (tax, shipping, etc.) |
| **List comprehension** | Applies per-item discounts efficiently |
| **Automatic free shipping** | Removes shipping if subtotal exceeds $100 |
| **Validation Check** | Ensures discounts match prices |

---

**🔥 Bonus Challenge**

1️⃣ Auto-apply a tax rate (e.g., 5%) if no tax is provided.  
2️⃣ Apply different shipping fees based on total weight.

3️⃣ Round final total to nearest 0.05 (real-world rounding).
"""

def process_order(*prices, discounts=None, weights=None, shipping_rate_threshold=100, tax_rate=0.5, **extra_fees):
    # Edge cases
    if discounts is None:
        discounts = [0] * len(prices)

    if weights is None:
        weights = [1] * len(prices)

    if len(prices) != len(discounts):
        raise ValueError("Discounts list must be the same length as the prices list.")

    if len(prices) != len(weights):
        raise ValueError("Weights list must be the same length as the prices list.")

    itemized = [round(price * (1 - discount), 2) for price, discount in zip(prices, discounts)]
    subtotal = sum(itemized)

    total_weights = sum(weights)

    # Define weight-based shipping rate table
    shipping_rates = [
        (5, 5),   #  $5 for total weight ≤ 5kg
        (10, 10),  # $10 for total weight ≤ 10kg
        (20, 20),  # $20 for total weight ≤ 20kg
        (float('inf'), 30)  # $30 for anything above 20kg
    ]

    if total_weights <= 5:
        extra_fees["shipping"] = 5
    elif 5 < total_weights <= 10:
        extra_fees["shipping"] = 10
    elif 10 < total_weights <= 20:
        extra_fees["shipping"] = 20
    else:
        extra_fees["shipping"] = 30


    if subtotal >= shipping_rate_threshold and "shipping" in extra_fees:
        del extra_fees["shipping"]

    if extra_fees["tax"] == 0:
        extra_fees["tax"] = tax_rate * subtotal

    total_fees = sum(extra_fees.values()) if extra_fees else 0
    final_total = round(subtotal + total_fees)

    order_summary = {
        "Itemized prices (after discount)": itemized,
        "Discount applied" : discounts,
        "Subtotal": subtotal,
        "Extra fees": extra_fees,
        "Final subtotal": final_total
    }
    return order_summary
# ✅ Example Usage:
order = process_order(50, 30, 20, discounts=[0.1, 0.2, 0], weights=[3, 2, 6], shipping=5, tax=7)
print(order)

"""**🔴 Issues That Could Cause Failure**

1️⃣ Hardcoded Shipping Rate Conditions (Instead of Using `shipping_rates`)

- Problem? If shipping rates change, you must update multiple places in your code instead of just modifying `shipping_rates`.

✅ Fix: Use `next()` to dynamically find the correct rate:
```python
shipping_cost = next(rate for weight, rate in shipping_rates if total_weights <= weight)
extra_fees["shipping"] = shipping_cost
```

---

2️⃣ `extra_fees["tax"] == 0` Will Break if `tax` is Not in `extra_fees`

- Problem? Code will crash if `tax` isn’t included in `extra_fees`.

✅ Fix: Use `.get()` to safely handle missing keys:
```python
if extra_fees.get("tax", 0) == 0:
    extra_fees["tax"] = tax_rate * subtotal
```

---

3️⃣ `final_total = round(subtotal + total_fees)` (Rounds Too Early)
- You round the final total to the nearest whole number.
- Problem? Real-world invoices usually round to two decimal places (e.g., `$125.47`).
- Potential issue? If the challenge tests for accurate cents (`125.47` vs `125`), this will fail.

✅ Fix: Round to two decimal places:
```python
final_total = round(subtotal + total_fees, 2)
```

---

4️⃣ Edge Case: No Discounts or Weights Provided

- If `discounts=None` and `weights=None`, it defaults correctly, but:
- If a user only provides `discounts` but not `weights`, or vice versa, it could be confusing.

✅ Fix: Print warnings (optional) if defaults are used:
```python
if discounts is None:
    print("Warning: No discounts provided. Defaulting to 0% for all items.")
    discounts = [0] * len(prices)

if weights is None:
    print("Warning: No weights provided. Defaulting to 1kg per item.")
    weights = [1] * len(prices)
```

---

**🔥 Bonus Challenge**

Want to take it to the next level? Try these:

1️⃣ Add express shipping options (`"standard"` vs `"express"` at different rates).  
2️⃣ Allow different tax rates per item category (e.g., `{"electronics": 0.1, "clothing": 0.05}`).  
3️⃣ Format the output in a user-friendly receipt style instead of raw JSON.

# **🚀 Step 4: Debugging & Error Handling Like a Pro**

**1️⃣ Common Errors and How to Fix Them**

Here are the most common Python errors and how to handle them properly.

**🔹 `KeyError` (Missing Key in Dictionary)**

Occurs when accessing a key that doesn’t exist in a dictionary.

**🚨 Example (Error)**
```python
data = {"name": "Alice", "age": 25}
print(data["salary"])  # ❌ KeyError: 'salary'
```

✅ Fix: Use `.get()` to Avoid the Error
```python
print(data.get("salary", "Not Found"))  # Output: Not Found
```

---

**🔹 `IndexError` (List Index Out of Range)**

Occurs when trying to access an index that doesn’t exist in a list.

**🚨 Example (Error)**
```python
nums = [10, 20, 30]
print(nums[5])  # ❌ IndexError: list index out of range
```

✅ Fix: Check Length Before Accessing
```python
index = 5
if index < len(nums):
    print(nums[index])
else:
    print("Index out of range")
```

---

**🔹 `TypeError` (Wrong Data Type)**

Occurs when performing an operation on incompatible types.

**🚨 Example (Error)**
```python
print("The number is: " + 10)  # ❌ TypeError: can only concatenate str (not "int") to str
```

✅ Fix: Convert Data Type
```python
print("The number is: " + str(10))  # Output: The number is: 10
```

---

**🔹 `ValueError` (Wrong Value for a Data Type)**

Occurs when a function receives a valid data type but an invalid value.

**🚨 Example (Error)**
```python
num = int("xyz")  # ❌ ValueError: invalid literal for int()
```

✅ Fix: Use `try-except`
```python
try:
    num = int("xyz")
except ValueError as e:
    print(f"Error: {e}")  # Output: Error: invalid literal for int()
```

---

**2️⃣ Advanced Error Handling with `try-except-finally`**

Sometimes, you need to handle errors properly while ensuring some code always runs.

Example: Handling Multiple Errors
```python
try:
    nums = [10, 20, 30]
    print(nums[5])  # IndexError
    result = 10 / 0  # ZeroDivisionError
except IndexError:
    print("Index out of range!")
except ZeroDivisionError:
    print("Cannot divide by zero!")
except Exception as e:
    print(f"Unexpected error: {e}")
finally:
    print("This always runs, no matter what.")
```

- First error (`IndexError`) is caught, so the `ZeroDivisionError` never occurs.
- `finally` ensures cleanup code runs (e.g., closing files, releasing resources).

---

**3️⃣ Debugging Like a Pro**

Debugging is about finding and fixing errors fast. Here are powerful techniques.

**✅ Use `print()` for Quick Debugging**
```python
def divide(a, b):
    print(f"Debug: a={a}, b={b}")  # Debugging
    return a / b

print(divide(10, 2))
```

---

**✅ Use `assert` to Check Conditions**

`assert` helps find unexpected issues during development.
```python
def get_age(age):
    assert age > 0, "Age must be positive!"  # Checks condition
    return f"Your age is {age}"

print(get_age(-5))  # AssertionError: Age must be positive!
```

---

**✅ Use `pdb` (Python Debugger) to Step Through Code**

`pdb` allows you to pause execution, inspect variables, and step through code interactively.
```python
import pdb

def buggy_function(x):
    pdb.set_trace()  # Debug mode starts here
    return x + 10

buggy_function(5)
```
💡 Press `n` to step through, `c` to continue, `q` to quit.

---

**4️⃣ Writing Robust Code: Best practices**

✅ Always handle expected errors (`try-except`).  
✅ Use `.get()` for dictionaries instead of direct key access.  
✅ Use list comprehensions carefully to avoid `IndexError`.  
✅ Use `print()` or `logging` for debugging, not blindly guessing.  
✅ Use `assert` to enforce critical conditions during testing.  

---

**🔥 Debugging Challenge**

This one will test your error-handling skills, debugging strategies, and Python knowledge.

Your Task: Find and fix all the bugs in the function below. It’s meant to:
- Read a CSV file.
- Filter rows where "age" is greater than 30.
- Convert the "salary" column to float and increase it by 10%.
- Return a new CSV file with updated salaries.

---

**❌ Buggy Code:**
```python
import csv

def process_csv(input_file, output_file):
    with open(input_file, "r") as file:
        data = csv.reader(file)
        header = next(data)  # Read header row
        results = []

        for row in data:
            if row["age"] > 30:  # 🔴 Bug 1
                row["salary"] = float(row["salary"]) * 1.1  # 🔴 Bug 2
                results.append(row)

    with open(output_file, "w") as file:
        writer = csv.writer(file)
        writer.writerow(header)
        writer.writerow(results)  # 🔴 Bug 3

    return f"Processed {len(results)} rows successfully"

# Example usage:
print(process_csv("employees.csv", "updated_employees.csv"))
```
"""

import csv

def process_csv(input_file, output_file):
    with open(input_file, "r") as file:
        data = csv.reader(file)
        header = next(data)  # Read header row
        results = []

        # Get index positions for age and salary
        age_index = header.index("age")
        salary_index = header.index("salary")

        for row in data:
            if int(row[age_index]) > 30:  # 🔴 Bug 1
                row[salary_index] = str(round(float(row[salary_index]) * 1.1, 2))  # 🔴 Bug 2
                results.append(row)

    with open(output_file, "w") as file:
        writer = csv.writer(file)
        writer.writerow(header)
        writer.writerows(results)  # 🔴 Bug 3

    return f"Processed {len(results)} rows successfully"

# Example usage:
print(process_csv("employees.csv", "updated_employees.csv"))

"""# **🚀 Step 5: File Handling & JSON Parsing**
✅ Why Should You Learn This?  
- JSON is everywhere: APIs, config files, databases, logs.  
- Python’s `json` library is optimized for working with structured data.

---

**1️⃣ When to Use the `json` Library vs. Built-in Functions**

| **Use Case** | **Use `json` Library?** | **Why?** |
|-------------|----------------|--------|
| **Saving structured data** | ✅ Yes | JSON preserves structure (dicts, lists, etc.) |
| **Reading structured files (`.json`)** | ✅ Yes | JSON allows structured parsing |
| **Processing API responses** | ✅ Yes | APIs return data in JSON format |
| **Storing temporary simple data** | ❌ No | Use `str()` / `eval()` for one-time storage |
| **Storing large amounts of data** | ❌ No | Use databases (e.g., SQLite, PostgreSQL) |

💡 **Key Takeaway:**  
- Use `json` for structured, shareable data (APIs, config files, logs).  
- For quick string storage, use `str()` or `repr()` instead.  

---

**2️⃣ Core `json` Operations**

| **Operation** | **Function** | **Description** |
|--------------|-------------|----------------|
| **Convert dict → JSON string** | `json.dumps()` | Converts Python dict into a JSON-formatted string |
| **Convert JSON string → dict** | `json.loads()` | Parses a JSON string into a Python dict |
| **Write dict to JSON file** | `json.dump()` | Saves Python dict as a `.json` file |
| **Read JSON file into a dict** | `json.load()` | Loads JSON data from a `.json` file into a Python dict |

---

**3️⃣ Essential `json` Library Functions**

🔹 Convert Python Dictionary → JSON String (`dumps()`)
```python
import json

data = {"name": "Alice", "age": 25, "city": "New York"}
json_string = json.dumps(data)

print(json_string)  
# Output: '{"name": "Alice", "age": 25, "city": "New York"}'
```

---

🔹 Convert JSON String → Python Dictionary (`loads()`)
```python
json_string = '{"name": "Bob", "age": 30}'
data = json.loads(json_string)

print(data["name"])  # Output: Bob
```
---

🔹 Save Python Dictionary as JSON File (`dump()`)
```python
from textwrap import indent
data = {"name": "Charlie", "age": 40}

with open("data.json", "w") as f:
    json.dump(data, f, indent=4)  # Pretty-print JSON
```
---

🔹 Read JSON File and Convert to Python Dictionary (`load()`)
```python
with open("data.json", "r") as f:
    loaded_data = json.load(f)

print(loaded_data["age"])  # Output: 40
```
---

**4️⃣ Common Pitfalls & Fixes**

| **Mistake** | **Issue** | **Fix** |
|------------|----------|--------|
| **Forgetting to convert JSON string** | `TypeError: string indices must be integers` | Use `json.loads()` before accessing keys |
| **Writing to JSON file without indent** | Hard-to-read JSON | Use `indent=4` in `json.dump()` |
| **Using `eval()` instead of `json.loads()`** | Security risk | Always use `json.loads()` |

---

**🔥 Challenge**

1️⃣ Read a JSON file (`users.json`) containing a list of users.  
2️⃣ Filter out users younger than 30.  
3️⃣ Save the filtered data into a new file (`filtered_users.json`).
"""

from textwrap import indent
with open("users.json", "r") as file:
    data = json.load(file)

data_filtered = list(filter(lambda user: user["age"] >= 30, data))

with open("filtered_users.json", "w") as file:
    json.dump(data_filtered, file, indent=4)

"""# **🚀 Step 6: Numpy-The Ultimate Performance Boost**
✅ When dealing with large data use NumPy instead of loops.

Examples:
```python
import numpy as np
arr = np.array([1, 2, 3, 4])
```

**Vectorized operations (100x faster than loops)**
```python
print(arr * 2)
print(arr + arr)
```

# **🚀 Step 7. Quick Guide to Python's `logging` Library**
✅ **Why Use `logging` Instead of `print()`?**  
- Logs persist in a file (`errors.log`) for debugging later.  
- Can set different logging levels (`DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`).  
- More control over output format & location.  

---

**1️⃣ Basic Setup for Logging**
```python
import logging

# Configure logging
logging.basicConfig(
    filename="app.log",  # Save logs in a file
    level=logging.DEBUG,  # Set logging level
    format="%(asctime)s - %(levelname)s - %(message)s"  # Format log messages
)

# Logging messages
logging.debug("This is a debug message.")  
logging.info("This is an info message.")  
logging.warning("This is a warning.")  
logging.error("This is an error!")  
logging.critical("Critical issue!")
```
Expected Output (`app.log` file):
```
2024-03-15 12:00:01 - DEBUG - This is a debug message.
2024-03-15 12:00:02 - INFO - This is an info message.
2024-03-15 12:00:03 - WARNING - This is a warning.
2024-03-15 12:00:04 - ERROR - This is an error!
2024-03-15 12:00:05 - CRITICAL - Critical issue!
```

---

**2️⃣ Using Logging in a Function**
```python
def divide(a, b):
    if b == 0:
        logging.error("Attempted division by zero.")
        return None
    result = a / b
    logging.info(f"Division successful: {a} / {b} = {result}")
    return result

print(divide(10, 2))  # Logs INFO message
print(divide(10, 0))  # Logs ERROR message
```

---

**3️⃣ Writing Logs to Console & File Simultaneously**
```python
logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("app.log"),  # Logs to file
        logging.StreamHandler()  # Logs to console
    ]
)
```

##🔍  Coding Challenge
📌 Write a function that:
1. Reads a JSON file.
2. Extracts only users whose `age > 25`.
3. Sort the results by age.
4. Increase the salary by 10%
5. Writes the filtered result to another JSON file.
6. Sort by department first, then age.
7. Allow the user to specify the salary increase percentage dynamically (increase_percent=0.1).
8. Save errors to a log file instead of printing them.
9. Allow filtering by multiple conditions (e.g., age and department).
10. Save the processed data in a CSV file instead of JSON (csv.writer).
"""

import json
import logging

logging.basicConfig(filename="errors.log",
                    level=logging.ERROR,
                    format="%(asctime)s - %(levelname)s - %(message)s")

def process_employees(input_data, output_data, output_csv_data, threshold=25, increase_percent=0.1, departments=None):
    if not input_data or not output_data:
        raise ValueError("Input and Output file must be provided")
    if not departments or not isinstance(departments, list):
        raise ValueError("A list of department names must be provided")
    try:
        with open(input_data, "r") as file:
            data = json.load(file)

        filtered_data = list(filter(lambda user: (user["age"] > threshold and user["department"] in departments, data)))

        sorted_data = list(sorted(filtered_data, key= lambda x: (x["department"], -x["age"])))

        updated_data = list(map(lambda user: {**user, "salary": round(user["salary"] * (1 + increase_percent), 2)}, sorted_data))

        with open(output_data, "w") as file:
            json.dump(updated_data, file, indent=4)

        with open(output_csv_data, "w") as file:
            writer = csv.writer(file)
            writer.writerow([["name", "age", "salary", "department"]]) # headers

            for user in updated_data:
                writer.writerows([user["name"], user["age"], user["salary"], user["department"]]) #rows

    except Exception as e:
        logging.error(f"Unexpected error: {e}")

    return f"Processed {len(updated_data)} employees successfully."

print(process_employees(
    "employees.json", "processed_employees.json", "processed_employees.csv",
    threshold=30, increase_percent=0.15, departments=["Engineering", "HR"]
))

"""# **🚀 Step 8. Code Refactoring Guide**
✅ **Why Refactor?**  
- Improves readability & maintainability
- Reduces redundancy & improves efficiency  
- Follows clean coding principles**  

---

**📌 1️⃣ Key Refactoring Techniques**

| **Technique** | **What It Does** | **Example Before** | **Example After** |
|--------------|----------------|-----------------|-----------------|
| **Extract Functions** | Breaks large functions into smaller, reusable ones | Function does too many things | Creates separate functions for clarity |
| **Use List Comprehensions** | Replaces long loops with clean one-liners | Uses `for` loops for filtering/mapping | Uses `[x for x in lst if x > 10]` |
| **Remove Magic Numbers** | Replaces hardcoded values with constants | `if salary > 50000:` | `if salary > HIGH_SALARY_THRESHOLD:` |
| **Improve Naming** | Uses meaningful variable & function names | `x, y = 5, 10` | `min_age, max_age = 5, 10` |

---

**📌 2️⃣ Extracting Functions (Refactor Large Functions)**

```python
def process_data(data):
    cleaned_data = []
    for d in data:
        if d > 10:
            cleaned_data.append(d * 2)

    total = sum(cleaned_data)
    avg = total / len(cleaned_data) if cleaned_data else 0
    return f"Sum: {total}, Avg: {avg}"
```
Refactored Version (Better Readability & Reusability)
```python
def clean_data(data):
    return [d * 2 for d in data if d > 10]

def calculate_summary(cleaned_data):
    total = sum(cleaned_data)
    avg = total / len(cleaned_data) if cleaned_data else 0
    return {"sum": total, "average": avg}

def process_data(data):
    cleaned = clean_data(data)
    return calculate_summary(cleaned)
```

---

**📌 3️⃣ Using List Comprehensions**

Problem: The function uses unnecessary loops.
```python
def double_large_numbers(data):
    result = []
    for d in data:
        if d > 10:
            result.append(d * 2)
    return result
```

```python
def double_large_numbers(data):
    return [d * 2 for d in data if d > 10]
```

---

**📌 4️⃣ Replacing Magic Numbers with Constants**

Problem: Hardcoded values like `10` and `50000` reduce readability.
```python
def is_high_salary(salary):
    return salary > 50000
```

```python
HIGH_SALARY_THRESHOLD = 50000

def is_high_salary(salary):
    return salary > HIGH_SALARY_THRESHOLD
```

---

**📌 5️⃣ Improving Variable & Function Names**

Problem: Poor variable names make code harder to read.
```python
def calc(x, y):
    return x + y

print(calc(10, 20))  # What is calc? What do x & y represent?
```

```python
def add_numbers(num1, num2):
    return num1 + num2

print(add_numbers(10, 20))  # Clear function & variable names
```

---

**🔥 Refactoring Challenge**

Problem: The function below is messy, redundant, and hard to understand.
```python
def process_employees(data):
    employees_over_30 = []
    for employee in data:
        if employee["age"] > 30:
            employee["salary"] = employee["salary"] * 1.1
            employees_over_30.append(employee)
    sorted_employees = sorted(employees_over_30, key=lambda x: x["salary"], reverse=True)
    return sorted_employees
```
✅ Your Task:  
- Extract filtering, salary update, and sorting into separate functions.
- Use list comprehensions where possible.
- Improve function & variable names.

**🔥 Bonus Challenge**

Want to push this further? Try:

1️⃣ Sort by department first, then by salary.

2️⃣ Write the final sorted data to a JSON file (`processed_employees.json`).
"""

def filtering_employees(data):
    if not data:
        raise ValueError("The data is empty")
    return [employee for employee in data if employee["age"] > 30]

def salary_update(data):
    if not data:
        raise ValueError("The data is empty")
    return [{**employee, "salary": round(employee["salary"] * 1.1, 2)} for employee in data]

def sorting(data):
    if not data:
        raise ValueError("The data is empty")
    return sorted(data, key=lambda x: (x["department"], -x["salary"]))

data = [
    {"name": "Alice", "age": 25, "salary": 50000, "department": "HR"},
    {"name": "Bob", "age": 40, "salary": 60000, "department": "Engineering"},
    {"name": "Charlie", "age": 35, "salary": 55000, "department": "Engineering"}
]

# Use case
filtered_data = filtering_employees(data)
salary_updated_data = salary_update(filtered_data)
sorted_data = sorting(salary_updated_data)

sorted_data

import json
with open("processed_employees.json", "w") as file:
    json.dump(sorted_data, file, indent=4)

"""# **🚀 Step 9. Master OOP in Record Time**

| **Concept** | **What It Does** | **Why It Matters? (80/20 Rule)** |
|------------|----------------|--------------------------------|
| **Class** | Blueprint for creating objects | Used in 90% of real-world applications |
| **Instance (`self`)** | A specific object of a class | You work with instances in actual code |
| **Constructor (`__init__`)** | Initializes object attributes | Automates object setup |
| **Inheritance** | One class inherits from another | Reuses code, prevents duplication |
| **Encapsulation** | Hides details (`_protected`, `__private`) | Controls how data is accessed |
| **Polymorphism** | Different classes use the same method names | Flexible, reusable code |
| **Dunder Methods (`__str__`, `__repr__`)** | Customize object behavior | Makes debugging easy |

---

**🔴 Learn by Breaking (Then Fixing) Code:**

This messy class does too much and has bad design.
```python
class Employee:
    def __init__(self, name, age, salary, department):
        self.name = name
        self.age = age
        self.salary = salary
        self.department = department

    def details(self):
        return f"{self.name}, {self.age} - {self.department}, Salary: {self.salary}"

    def yearly_salary(self):
        return self.salary * 12
```
⏳ The Fix (Refactored, Modular, More Powerful)
"""

# The Employee class will store employee-related data and may later include methods for behavior.
# Why It Matters?
# Encapsulates all employee-related logic.
# Allows creating multiple employee objects without repeating code.
class Employee: # Define a slass

    company="TechCorp" # Class attribute shared by all employess
    #All employees belong to the same company, so "TechCorp" shouldn’t be stored in every instance.

    # __init__(self, ) is the constructor method and it instanciates the class object
    # by initializing the attributes (name, age, salary, department)
    # The constructor takes the attributes as arguments
    def __init__(self, name, age, salary, department):
        self.name=name  # self.name creates an instance attribute name that belongs to the object.
        # self refers to the current instance, so every object has its own copy of name
        self.age=age
        self.salary=salary
        self.department=department

        # Better practice → Use __str__() for human-readable representations.
        def __str__(self):
            return f"{self.name}, {self.age}-{self.department}, salary: {self.salary}"

        # The original method yearly_salary() was just a calculation.
        # Better practice → Use @property for computed values that don’t require extra parameters.
        @property
        def yearly_salary(self):
            return self.salary * 12

        # Added a Class Method to Update the Company Name
        # This allows changing the company name for all employees at once.
        @classmethod
        def set_company(cls, new_company):
            cls.company = new_company

        # Added a Static Method for Tax Deduction

        @staticmethod
        # This function doesn’t need self or cls.
        # It’s an independent utility function → It belongs inside Employee but doesn’t depend on an instance.
        def tax_deduction(Salary):
            return salary * 0.22

"""**🔥 When to Assign `self.attribute = value` vs. `self.attribute = None`?**

You have two main choices when initializing attributes in a class:  

1️⃣ Assigning them directly (`self.age = age`)  
2️⃣ Setting them to `None` initially (`self.age = None`)

---

1️⃣ Assigning a Value Immediately (`self.age = age`)

✅ When to Use This?
- When all required values are provided during object creation.
- When the attribute is necessary for the object to function.
- When there’s no reasonable default.

🔥 Example: Required Employee Information
```python
class Employee:
    def __init__(self, name, age, salary):
        self.name = name  # Required (must be provided)
        self.age = age  # Required
        self.salary = salary  # Required

emp1 = Employee("Alice", 30, 60000)
print(emp1.age)  # Output: 30
```
🚀 Why?  
- Every `Employee` must have a `name`, `age`, and `salary`, so they’re set immediately.  
- The object shouldn’t exist without them.  

---

2️⃣ Setting to `None` (`self.age = None`)

✅ When to Use This?
- When the attribute is optional or not always known at creation.
- When a default value will be set later.
- When you want to prevent incorrect initialization with a placeholder.

🔥 Example: Optional Attributes
```python
class Employee:
    def __init__(self, name, salary, age=None):
        self.name = name
        self.salary = salary
        self.age = age  # Optional (can be set later)

emp1 = Employee("Alice", 60000)  # No age provided
print(emp1.age)  # Output: None (can be updated later)
```
🚀 Why?  
- Some employees might not have an age recorded yet.  
- You don’t force users to input unnecessary data at creation.

---

🔥 Key Differences

| **Approach** | **When to Use** | **Example** |
|-------------|----------------|------------|
| `self.age = age` | Mandatory attributes | `self.name, self.salary` |
| `self.age = None` | Optional attributes | `self.age, self.phone_number` |

---

**🔥 Best Practice: Allowing Defaults**
You can combine both approaches:
```python
class Employee:
    def __init__(self, name, salary, age=None):  
        self.name = name
        self.salary = salary
        self.age = age if age is not None else 25  # Default to 25 if not provided
```
Now, `age` defaults to `25` unless explicitly set.

**🔥 Step 3: 3-Minute Speed Round**

💡 Use this mental model when thinking about OOP in real-world scenarios:

| **Use Case** | **What to Use?** | **Example** |
|-------------|---------------|------------|
| **Need to store data?** | Use `__init__` to set up attributes | Employee(name, salary) |
| **Want objects to print nicely?** | Use `__str__()` | `print(obj)` |
| **Need to compute a value?** | Use `@property` | `obj.yearly_salary` |
| **Want to modify a shared value?** | Use `@classmethod` | `Employee.set_company()` |
| **Need a utility function?** | Use `@staticmethod` | `Employee.tax_deduction()` |

**🔴 OOP Refactoring Example #2: Messy Student Management System**

Let’s refactor a poorly designed `Student` class by applying the same principles we used for `Employee`.  

```python
class Student:
    def __init__(self, name, age, grades):
        self.name = name
        self.age = age
        self.grades = grades  # List of grades

    def average_grade(self):
        return sum(self.grades) / len(self.grades)

    def details(self):
        return f"{self.name} ({self.age} years old) - Average Grade: {self.average_grade()}"

students = [
    Student("Alice", 20, [85, 90, 92]),
    Student("Bob", 21, [78, 85, 80])
]

print(students[0].details())
```
"""

class Student:
    school_name="Palo Alto Highschool"

    def __init__(self, name, age, grades):
        self.name=name
        self.age = age if age is not None else 99 # Set the fill value
        self.grades = grades

    @classmethod
    def change_school(cls, name):
        cls.school_name = name

    @property
    def average_grade(self):
        return sum(self.grades) / len(self.grades) if self.grades else 0

    def __str__(self):
        return f"{self.name} ({self.age} years old) - Agerage grade: {self.average_grade}"

    @staticmethod
    def is_passing(grade):
        return grade >= 60


# ✅ Create Students
students = [
    Student("Alice", 20, [85, 90, 92]),
    Student("Bob", 21, [78, 85, 80])
]

# ✅ Print details
print(students[0])  # ✅ Calls __str__()

# ✅ Access properties
print(students[0].average_grade)  # ✅ Accessed like an attribute

# ✅ Call static method
print(Student.is_passing(75))  # ✅ Output: True
print(Student.is_passing(50))  # ✅ Output: False

# ✅ Change school for all students
Student.change_school("Tech Academy")
print(students[1])  # ✅ Now Bob's school is "Tech Academy"

"""**🔴 Break, Fix, Repeat (Live Debugging Exercise)**

❌ The function below is broken. It should:

1. Filter employees by age
2. Increase their salary by 10%  
3. sort them by salary  
4. Print a readable summary  

```python
class Employee:
    def __init__(self, name, age, salary):
        self.name = name
        self.age = age
        self.salary = salary

    def __str__(self):
        return f"{self.name} - ${self.salary}"

def process_employees(data):
    employees_over_30 = list(filter(lambda emp: emp.age > 30, data))
    sorted_employees = sorted(employees_over_30, key=lambda x: x.salary, reverse=True)
    salary_updated = map(lambda emp: emp.salary * 1.1, sorted_employees)
    return list(salary_updated)

# ✅ FIX THIS: It should return Employee objects with updated salaries, not just numbers.
```

# **🚀 Step 10: Writing & Running Tests Like a Pro**

✅ **Why does this matter?**
- You must test your code in the interview. Expect to write test cases on the spot.
- Catch bugs and edge cases before they happen.
- Clean, testable code = strong engineering skills.

---

**🔥 1. The 3 Types of Test Cases**

🔹 **Happy Path**: The expected, normal inputs.  
🔹 **Edge Cases**: Extreme values, missing values, empty inputs, huge inputs.  
🔹 **Error Cases**: Handling of invalid types, out-of-bounds indices, missing keys.

---

**✅ What Are Unit Tests?**

- Test a single function or method at a time (smallest unit of code).  
- Run independently of other tests.  
- Verify expected outputs & error handling.  
- Use assertions (`assert`) to check correctness.  
- Catch bugs early before integrating with other parts of the system.

**✅ Unit tests ensure that each function does exactly what it's supposed to do—nothing more, nothing less.**

**✅ Unit Tests vs. Other Types of Tests**

| **Test Type** | **What It Does** | **Example** |
|--------------|-----------------|-------------|
| **Unit Test** | Tests a single function in isolation | `test_discount_calculator()` |
| **Integration Test** | Tests multiple components working together | API + database interaction |
| **System Test** | Tests the entire application as a user would | Full end-to-end scenario |

💡Unit tests are the foundation of all testing! If unit tests fail, bigger system tests are guaranteed to fail too.

**🔥 2. Mastering Pytest in 5 Minutes****
**Setting Up `pytest` (The Best Testing Tool for Python)
✅ Install `pytest` (if not already installed):  
```bash
pip install pytest
```

✅ Run all tests in your project:  
```bash
pytest -v
```
- `-v` → **Verbose mode** (see detailed output).  
- `--maxfail=1` → **Stops after one failure** (useful for debugging).  

---

**🔥 3. Writing Your First Unit Test**

**1. The Function to Test**
```python
def square_numbers(numbers):
    '''Returns a list of squared numbers.'''
    if not isinstance(numbers, list):
        raise TypeError("Input must be a list")
    return [n ** 2 for n in numbers]
```

**2. The Test Case**
Create a file called **`test_my_script.py`**:
```python
import pytest
from my_script import square_numbers  # Import the function

def test_square_numbers():
    assert square_numbers([1, 2, 3]) == [1, 4, 9]  # Normal case
    assert square_numbers([-1, -2, -3]) == [1, 4, 9]  # Handles negatives
    assert square_numbers([]) == []  # Edge case (empty list)

    with pytest.raises(TypeError):  # Expecting a TypeError
        square_numbers("hello")  # Wrong input type (string instead of list)
```
**3. Run the test**:
```bash
pytest test_my_script.py -v
```

---

**🔥 4. Identifying & Handling Edge Cases**
💡 Every function should be tested with:

| **Edge Case** | **Example Input** | **Expected Behavior** |
|--------------|------------------|------------------|
| **Empty Input** | `[]` | Returns `[]` |
| **Large Input** | `[9999999]` | Handles without crash |
| **Invalid Type** | `"hello"` | Raises `TypeError` |
| **Negative Numbers** | `[-5, -10]` | Correctly squares them |

✅ **Test Edge Cases for a Discount Calculator**
```python
import pytest
from my_script import discount_calculator  # Import function

def test_discount_calculator():
    assert discount_calculator([100, 200, 300]) == [90.0, 180.0, 270.0]  # ✅ Normal case
    assert discount_calculator([]) == []  # ✅ Empty input
    assert discount_calculator([9999999]) == [8999999.1]  # ✅ Large numbers

    with pytest.raises(TypeError):  # ✅ Type error test
        discount_calculator("hello")  # ❌ Wrong input type
```

---

**🔥 5. Parameterized Testing (Avoid Repetition)**

If you have multiple test cases with similar logic, use `@pytest.mark.parametrize()`:
```python
@pytest.mark.parametrize("input_data, expected", [
    ([1, 2, 3], [1, 4, 9]),
    ([], []),
    ([-1, -2], [1, 4])
])
def test_square_numbers(input_data, expected):
    assert square_numbers(input_data) == expected
```
🚀 **This replaces multiple `assert` statements with a single, dynamic test.**

---

**🔥 6. Test-Driven Development (TDD)**

- **Write tests BEFORE writing the function.**
- **Make tests fail first** → Then write the function to pass them.  

✅ **Example TDD Workflow**
```python
# ✅ Step 1: Write a failing test
def test_reverse_string():
    assert reverse_string("hello") == "olleh"
```
```python
# ✅ Step 2: Implement the function to make the test pass
def reverse_string(s):
    return s[::-1]  # ✅ Now the test passes
```

---

**🔥 7. Running & Debugging Tests**
**Run all tests with detailed output:**  
```bash
pytest -v
```
**Stop after the first failure:**  
```bash
pytest --maxfail=1
```
**Run a specific test only:**  
```bash
pytest -k "test_square_numbers"
```

---

**🔥 8. Best Practices for Testing**
✅ Each test should test ONE thing.  
✅ Use meaningful test names (`test_handles_large_numbers`).  
✅ Always include edge cases (empty, large, wrong types).  
✅ Keep test files separate (`test_my_script.py`).  
✅ Use `pytest.mark.parametrize()` to reduce repetition.  

---

**🔥 9. Challenges**

Fix This Test:
```python
def test_discount():
    assert apply_discount([100, 200]) == [90, 180]
    assert apply_discount([]) == None  # ❌ Bug here!
```
Find the mistake & explain why!

Here’s a real-world function. Write test cases for it.
```python
def discount_calculator(prices, discount=0.1):
    '''Applies a discount to a list of prices.'''
    if not isinstance(prices, list) or any(not isinstance(p, (int, float)) for p in prices):
        raise TypeError("Prices must be a list of numbers.")
    
    return [round(p * (1 - discount), 2) for p in prices]
```
💡 Test it like a pro!
- Normal case: `[100, 200, 300]`
- Edge case: `[]`
- Large numbers: `[9999999]`
- Wrong type: `"hello"`
- Negative numbers: `[-10, -20]`

---

🚀 Final Step: Run all tests before submitting code!
```bash
pytest --maxfail=1 --disable-warnings -v
```

**Fix This Broken Test**

The test below has a hidden mistake. Find it and fix it!
```python
def test_square_numbers():
    assert square_numbers([1, 2, 3]) == [1, 4, 9]
    assert square_numbers([-1, -2, -3]) == [1, 4, 9]
    assert square_numbers([]) == None  # ❌ Bug here!
```

#**🚀 Step 11: Design Patterns in Python: A Practical Guide**
Design patterns are proven solutions to common software design problems. They help create scalable, reusable, and maintainable code by providing a structured approach to problem-solving.

---

**📌 Why Use Design Patterns?**

✅ Improve code readability & maintainability  
✅ Encourage best practices  
✅ Provide reusable solutions  
✅ Make code flexible for future changes

---

**🔥 Types of Design Patterns**

Design patterns are categorized into three main types:

| **Pattern Type** | **Purpose** | **Example Patterns** |
|----------------|------------|----------------|
| **Creational** | How objects are created | Singleton, Factory, Builder |
| **Structural** | How objects are organized | Adapter, Decorator, Facade |
| **Behavioral** | How objects interact | Observer, Strategy, Command |

---

**🔥 1. Creational Patterns (Object Creation)**

Creational patterns focus on how objects are created efficiently.

**✅ Singleton Pattern (Only One Instance)**

Ensures a class has only one instance and provides a global access point.

```python
class Singleton:
    _instance = None  # Store the instance

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(Singleton, cls).__new__(cls)
        return cls._instance

# Usage
s1 = Singleton()
s2 = Singleton()
print(s1 is s2)  # ✅ True (Same instance)
```
📌 **When to Use?**  
- **Logging systems** (Ensure only one logger exists).
- **Database connections** (Avoid multiple connections).
- **Configuration settings** (Use a single configuration object).

---

**✅ Factory Pattern (Object Creation Based on Input)**

Creates objects without specifying the exact class.

```python
class Car:
    def drive(self):
        return "Driving a car"

class Bike:
    def drive(self):
        return "Riding a bike"

class VehicleFactory:
    @staticmethod
    def get_vehicle(vehicle_type):
        if vehicle_type == "car":
            return Car()
        elif vehicle_type == "bike":
            return Bike()
        else:
            raise ValueError("Invalid vehicle type")

# Usage
vehicle = VehicleFactory.get_vehicle("car")
print(vehicle.drive())  # ✅ "Driving a car"
```
📌 **When to Use?**  
- When object creation logic is complex.  
- When the type of object depends on user input or configuration.  

---

**🔥 2. Structural Patterns (How Objects Are Organized)**

Structural patterns focus on how classes and objects are structured.

**✅ Adapter Pattern (Bridge Between Incompatible Interfaces)**

Allows two incompatible interfaces to work together.

```python
class OldSystem:
    def legacy_method(self):
        return "Old system response"

class Adapter:
    def __init__(self, old_system):
        self.old_system = old_system

    def new_method(self):
        return self.old_system.legacy_method()

# Usage
adapter = Adapter(OldSystem())
print(adapter.new_method())  # "Old system response"
```
📌 **When to Use?**  
- When integrating legacy code into a new system.  
- When working with third-party APIs that have a different interface.  

---

**✅ Decorator Pattern (Enhancing Functionality Without Modifying Base Class)**

Allows adding features to an object dynamically without modifying the original class.

```python
def uppercase_decorator(func):
    def wrapper():
        return func().upper()
    return wrapper

@uppercase_decorator
def greet():
    return "hello"

print(greet())  # "HELLO"
```
📌 **When to Use?**  
- adding logging, caching, or authentication without modifying core code.  
- Extending behavior dynamically instead of modifying original functions.  

---

**🔥 3. Behavioral Patterns (How Objects Interact)**

Behavioral patterns define how objects communicate.

**✅ Strategy Pattern (Swap Algorithms at Runtime)**

Encapsulates multiple algorithms and allows choosing one dynamically.

```python
class SortStrategy:
    def sort(self, data):
        pass  # Abstract method

class QuickSort(SortStrategy):
    def sort(self, data):
        return sorted(data)

class BubbleSort(SortStrategy):
    def sort(self, data):
        return "Bubble sorted list"

class SortContext:
    def __init__(self, strategy: SortStrategy):
        self.strategy = strategy

    def sort_data(self, data):
        return self.strategy.sort(data)

# Usage
context = SortContext(QuickSort())  # Using QuickSort
print(context.sort_data([3, 1, 2]))  # [1, 2, 3]

context.strategy = BubbleSort()  # Switch to BubbleSort
print(context.sort_data([3, 1, 2]))  # "Bubble sorted list"
```
📌 **When to Use?**  
- When you need multiple algorithms for the same task.  
- When runtime selection of an algorithm** is required.  

---

**✅ Observer Pattern (Event-Based Communication)**

Allows one object (subject) to notify multiple objects (observers) about state changes.

```python
class Observer:
    def update(self, message):
        pass  # Abstract method

class EmailNotifier(Observer):
    def update(self, message):
        print(f"Email Notification: {message}")

class Logger(Observer):
    def update(self, message):
        print(f"Logging: {message}")

class Subject:
    def __init__(self):
        self.observers = []

    def attach(self, observer):
        self.observers.append(observer)

    def notify(self, message):
        for observer in self.observers:
            observer.update(message)

# Usage
subject = Subject()
subject.attach(EmailNotifier())
subject.attach(Logger())

subject.notify("Fire detected!")  
# Email Notification: Fire detected!"
# "Logging: Fire detected!"
```
📌 **When to Use?**  
- When multiple parts of a system need to react to an event.  
- Used in event-driven systems like GUI applications & real-time monitoring.  

---

**🔥 Summary of Design Patterns**

| **Type** | **Pattern** | **Use Case** |
|----------|------------|-------------|
| **Creational** | **Singleton** | Ensure only one instance of a class exists (e.g., logging, database connection). |
| **Creational** | **Factory** | Create different types of objects based on input. |
| **Structural** | **Adapter** | Make incompatible interfaces work together. |
| **Structural** | **Decorator** | Add functionality without modifying original class. |
| **Behavioral** | **Strategy** | Swap between multiple algorithms at runtime. |
| **Behavioral** | **Observer** | Notify multiple components when an event occurs. |

---

**🚀 Which Patterns Should You Focus On?**
- **For Interview Prep:** Singleton, Factory, Strategy, Decorator.  
- **For Real-World Software:** Observer (Event-based), Adapter (Legacy Integration).  
- **For Scaling Applications:** Factory (Dynamic Object Creation), Strategy (Multiple Algorithms).

#**🚀  Step 12: SOLID Principles in Python (Object-Oriented Design Best Practices)**

The SOLID principles are five design principles that make object-oriented software more maintainable, scalable, and readable.

---

**📌 1. Single Responsibility Principle (SRP)**

💡 Each class should have only one reason to change.  
A class should only do one thing and should not have multiple responsibilities.

**🚀 Bad Example (Violates SRP)**
```python
class Order:
    def __init__(self, items):
        self.items = items
    
    def calculate_total(self):
        return sum(item['price'] for item in self.items)
    
    def save_to_db(self):
        print("Saving order to database...")  # 🚨 Mixing business logic & persistence
```
Why is this bad?
- The class calculates the total price AND saves data to the database.
- If we change how orders are stored, we have to modify this class, violating SRP.

**✅ Good Example (Follows SRP)**
```python
class Order:
    def __init__(self, items):
        self.items = items
    
    def calculate_total(self):
        return sum(item['price'] for item in self.items)

class OrderRepository:
    def save_to_db(self, order):
        print("Saving order to database...")
```
✅ Now:
- `Order` handles only price calculations.
- `OrderRepository` handles database operations.

---

**📌 2. Open/Closed Principle (OCP)**

💡 Classes should be open for extension but closed for modification.  
New functionality should be added without modifying existing code.

**🚀 Bad Example (Violates OCP)**
```python
class PaymentProcessor:
    def pay(self, method):
        if method == "credit":
            print("Processing credit card payment...")
        elif method == "paypal":
            print("Processing PayPal payment...")
```
Why is this bad?
- If we add a new payment method (e.g., Bitcoin), we must modify this class.

**✅ Good Example (Follows OCP)**
```python
from abc import ABC, abstractmethod

class PaymentMethod(ABC):
    @abstractmethod
    def pay(self):
        pass

class CreditCardPayment(PaymentMethod):
    def pay(self):
        print("Processing credit card payment...")

class PayPalPayment(PaymentMethod):
    def pay(self):
        print("Processing PayPal payment...")

class PaymentProcessor:
    def __init__(self, payment_method: PaymentMethod):
        self.payment_method = payment_method
    
    def process_payment(self):
        self.payment_method.pay()

# Usage
payment = PaymentProcessor(PayPalPayment())
payment.process_payment()
```
✅ Now:
- Adding new payment methods does not modify existing code.
- New classes like `BitcoinPayment` can be added without touching the original `PaymentProcessor` class.

---

**📌 3. Liskov Substitution Principle (LSP)**

💡 Subclasses should be replaceable with their base class without breaking the code.
A derived class should not change the expected behavior of its parent.

**🚀 Bad Example (Violates LSP)**
```python
class Bird:
    def fly(self):
        print("I can fly!")

class Penguin(Bird):
    def fly(self):
        raise Exception("Penguins can't fly!")  # 🚨 Unexpected behavior
```
Why is this bad?
- `Penguin` inherits from `Bird`, but calling `fly()` on `Penguin` breaks expectations.

**✅ Good Example (Follows LSP)**
```python
class Bird:
    def move(self):
        print("I can move!")

class FlyingBird(Bird):
    def fly(self):
        print("I can fly!")

class Penguin(Bird):
    def swim(self):
        print("I can swim!")

# Usage
sparrow = FlyingBird()
penguin = Penguin()

sparrow.fly()   # Works as expected
penguin.move()  # Works as expected
```
✅ Now:
- `Bird` defines general movement (`move()`).
- `FlyingBird` adds `fly()`, ensuring only flying birds have a `fly()` method.

---

**📌 4. Interface Segregation Principle (ISP)**

💡 Clients should not be forced to depend on methods they do not use.  
Instead of one large interface, create smaller, specific interfaces.

**🚀 Bad Example (Violates ISP)**
```python
class Worker:
    def work(self):
        pass
    
    def eat(self):
        pass  # 🚨 Not all workers need to eat (e.g., Robots)
```
Why is this bad?
- A Robot class would inherit `eat()`, which it does not need.

**✅ Good Example (Follows ISP)**
```python
from abc import ABC, abstractmethod

class Workable(ABC):
    @abstractmethod
    def work(self):
        pass

class Eatable(ABC):
    @abstractmethod
    def eat(self):
        pass

class Human(Workable, Eatable):
    def work(self):
        print("I am working!")
    
    def eat(self):
        print("I am eating!")

class Robot(Workable):
    def work(self):
        print("I am working non-stop!")

# Usage
worker = Human()
robot = Robot()

worker.work()
worker.eat()
robot.work()
```
Now:
- `Robot` only implements `Workable`.
- `Human` implements both `Workable` and `Eatable`.

---

**📌 5. Dependency Inversion Principle (DIP)**

💡 High-level modules should not depend on low-level modules. Both should depend on abstractions.  
Instead of hardcoding dependencies, use dependency injection.

**🚀 Bad Example (Violates DIP)**
```python
class MySQLDatabase:
    def connect(self):
        print("Connecting to MySQL...")

class UserService:
    def __init__(self):
        self.database = MySQLDatabase()  # 🚨 Direct dependency

    def get_user(self):
        self.database.connect()
        print("Fetching user data...")
```
Why is this bad?
- `UserService` is tightly coupled to `MySQLDatabase`.  
- If we switch to PostgreSQL, we must modify `UserService`.

**✅ Good Example (Follows DIP)**
```python
from abc import ABC, abstractmethod

class Database(ABC):
    @abstractmethod
    def connect(self):
        pass

class MySQLDatabase(Database):
    def connect(self):
        print("Connecting to MySQL...")

class PostgreSQLDatabase(Database):
    def connect(self):
        print("Connecting to PostgreSQL...")

class UserService:
    def __init__(self, database: Database):
        self.database = database  # Dependency Injection

    def get_user(self):
        self.database.connect()
        print("Fetching user data...")

# Usage
db = PostgreSQLDatabase()
user_service = UserService(db)
user_service.get_user()
```
Now:
- We can easily switch databases without modifying `UserService`.
- `UserService` depends on an abstract interface (`Database`) rather than a concrete class.

---

# **🔥 Summary: SOLID Principles in Python**
| **Principle** | **Definition** | **Fix** |
|--------------|---------------|--------|
| **SRP (Single Responsibility)** | A class should only have one reason to change. | Separate concerns into different classes. |
| **OCP (Open/Closed)** | Classes should be open for extension but closed for modification. | Use inheritance and interfaces instead of modifying existing code. |
| **LSP (Liskov Substitution)** | Subclasses should be replaceable without breaking the code. | Avoid overriding methods with different behaviors. |
| **ISP (Interface Segregation)** | Don’t force clients to depend on methods they don’t use. | Use smaller, specialized interfaces. |
| **DIP (Dependency Inversion)** | High-level modules should not depend on low-level modules directly. | Use abstraction and dependency injection. |

---

**🔥 Summary of Best Coding Practices**

| **Principle** | **Key Idea** |
|--------------|------------|
| **PEP 8 (Readability)** | Follow Python's style guide |
| **DRY (Don’t Repeat Yourself)** | Avoid redundant code, use functions |
| **KISS (Keep It Simple, Stupid)** | Don’t overcomplicate solutions |
| **YAGNI (You Ain’t Gonna Need It)** | Only write what’s necessary |
| **SRP (Single Responsibility Principle)** | Each function/class should do ONE thing |
| **Descriptive Naming** | Use meaningful variable & function names |
| **Error Handling** | Handle exceptions properly with `try-except` |
| **Test-Driven Development (TDD)** | Write unit tests before deployment |
| **Avoid Premature Optimization** | Optimize only when necessary |
| **Keep Functions Small** | Break large functions into modular parts |
"""

